! ============
! controls_dev
! ============

! CONTAINS OPTIONS THAT HAVE NOT YET BEEN THE GIVEN A GREEN LIGHT FOR GENERAL USE.
! IN PARTICULAR, THESE ARE NOT FOR USE IN RESEARCH TO BE PUBLISHED.


      ! D_smooth_replacement_fraction
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! D_smooth_growth_rate
      ! ~~~~~~~~~~~~~~~~~~~~
      ! set_D_mix_to_D_smooth
      ! ~~~~~~~~~~~~~~~~~~~~
      ! blend_D_smooth_between_cells_of_same_mixing_type
      ! ~~~~~~~~~~~~~~~~~~~~

      ! allows time-smoothing of mixing diffusion coeff at each step.
      ! at the beginning of each step, after setting usual D_mix.
      ! D_smooth(k) = (1d0 - f)*D_smooth_old(k) + f*D_mix(k)
      ! where f = min(dt*D_smooth_growth_rate, D_smooth_replacement_fraction)

      ! ::

    D_smooth_replacement_fraction = 0.5d0
    D_smooth_growth_rate = 1d0
    set_D_mix_to_D_smooth = .false.
    blend_D_smooth_between_cells_of_same_mixing_type = .false.


      D_mix_zero_region_bottom_q = 1d99
      D_mix_zero_region_top_q = -1d99
      dq_D_mix_zero_at_H_He_crossover = -1d0
      dq_D_mix_zero_at_H_C_crossover = -1d0
      
      
      


      ! Eturb parameters
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         
      !   Eturb_alfa  =     1.5d0         ! mixing length; alfa = 0 gives a purely radiative model.
      !   Eturb_alfap =     0.0d0         ! turbulent pressure; Pt ~ alfap     
      !   Eturb_alfat =     0.0d0         ! turbulent flux; Lt ~ Eturb_alfat
      !   Eturb_alfam =     0.25d0        ! turbulent viscosity; Eq and Uq ~ Eturb_alfam
      !   Eturb_alfar =     0.0d0         ! radiative dissipation of turbulent energy; Dr ~ Eturb_alfar    
      !      
      ! Eturb time weighting is determined by the Fraley_time_centering controls.
      !     for Pt and Lt in turbulent energy equation
      !     for P and grav in momentum equation
      !     for P and L in energy equation
      !     for area when multiplied by P
      ! Eturb_Lsurf_factor: Lsurf = Eturb_Lsurf_factor*area(1)*clight*crad*T(1)**4
      !   

      ! ::

    Eturb_alfa  = 1.5d0
    Eturb_alfap = 0.0d0
    Eturb_alfat = 0.0d0
    Eturb_alfam = 0.25d0
    Eturb_alfar = 0.0d0

    Eturb_Lsurf_factor = 0.5d0


      ! use_DGESVX_in_bcyclic
      ! use_equilibration_in_DGESVX
      ! report_min_rcond_from_DGESXV
      
      ! FOR DEBUGGING ONLY.   NOT FOR GENERAL USE.

      ! ::

    use_DGESVX_in_bcyclic = .false.
    use_equilibration_in_DGESVX = .false.
    report_min_rcond_from_DGESXV = .false.


      ! mlt_make_surface_no_mixing
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~

      ! this defaults to false for (temoporary) backward compatibility.
      ! it should be true.

      ! ::

    mlt_make_surface_no_mixing = .false.


      ! drag_coefficient
      ! ~~~~~~~~~~~~~~~~
      ! min_q_for_drag
      ! ~~~~~~~~~~~~~~
      ! turn_on_drag_in_H_envelope
      ! ~~~~~~~~~~~~~~

      ! only when v_flag.  adjusts both v and energy transfer from kinetic to thermal.
      ! only for v(k) when q(k) > min_q_for_drag.
      ! kill off fraction of v = drag_coefficient (i.e. set to 1 to keep v near 0)

      ! ::

    drag_coefficient = 0d0
    min_q_for_drag = 0d0
    turn_on_drag_in_H_envelope = .false.


      ! use_superad_reduction
      ! ~~~~~~~~~~~~~~~~~~~~~
      ! superad_reduction_Gamma_limit
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! superad_reduction_Gamma_limit_scale
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! superad_reduction_Gamma_inv_scale
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! superad_reduction_diff_grads_limit
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! superad_reduction_limit
      ! ~~~~~~~~~~~~~~~~~~~~~~~

      ! Implicit alternative to okay_to_reduce_gradT_excess, EXPERIMENTAL

      ! ::

    use_superad_reduction = .false.
    superad_reduction_Gamma_limit = 0.5d0
    superad_reduction_Gamma_limit_scale = 5d0
    superad_reduction_Gamma_inv_scale = 5d0
    superad_reduction_diff_grads_limit = 1d-3
    superad_reduction_limit = -1d0

! convection velocity equation
! ============================


      ! conv_vel_D
      ! ~~~~~~~~~~
      ! conv_vel_siglimit
      ! ~~~~~~~~~~~~~~~~~
      ! conv_vel_v0
      ! ~~~~~~~~~~~

      ! To avoid following tiny convective velocities to high precision
      ! as well as accounting for several orders-of-magnitude changes of
      ! conv_vel in individual steps, the variable included in the solver
      ! solver is not conv_vel, but instead ln(conv_vel + v0). v0 (in cm/s)
      ! then determines at which point relative errors in ln(conv_vel + v0)
      ! are small (TODO: explain better).

      ! ::

    conv_vel_D = 0d0
    conv_vel_siglimit = 1d99
    conv_vel_v0 = 1d0


      ! min_q_for_normal_mlt_gradT_full_off
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! max_q_for_normal_mlt_gradT_full_on
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      ! Switches from the gradT given by standard MLT rather than conv_vel in the outer layers
      ! gradT is smoothly blend between this range in q

      ! ::

    min_q_for_normal_mlt_gradT_full_off = 1d99
    max_q_for_normal_mlt_gradT_full_on = 1d99


      ! conv_vel_ignore_thermohaline
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! conv_vel_ignore_semiconvection
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      ! If false, then mlt will consider a convective velocity given by 3*D/Lambda
      ! as an additional source for the conv_vel equation (can be set for either
      ! thermohaline or semiconvective mixing). Thermohaline mixing can change
      ! a lot, and its inclusion makes things unstable, so by default we only keep
      ! semiconvection. It true, then the corresponding mixing coefficient is calculated
      ! in the regular way and added up to the final mixing coefficient.

      ! ::

    conv_vel_ignore_thermohaline = .true.
    conv_vel_ignore_semiconvection = .false.


      ! conv_vel_fully_lagrangian
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~
      ! conv_vel_include_homologous_term
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      ! If conv_vel_fully_lagrangian is true, then time derivatives for convective
      ! velocities are computed fully lagrangian, using values from the previous step
      ! at constant mass. Otherwise, on the outer layers of the star the term time
      ! derivative is computed using a time derivative at fixed mass
      ! ratio q (so-called non-homologous term), and the derivative with respect to q
      ! (so-called homologous term).
      ! if conv_vel_include_homologous_term is false, then the homologous term is
      ! ignored.

      ! ::

    conv_vel_fully_lagrangian = .false. 
    conv_vel_include_homologous_term = .true.


      ! conv_vel_use_mlt_vc_start
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~

      ! If true, then the value of the convective velocity from mlt is used
      ! throughout all solver iterations rather than being updated at each.

      ! ::

    conv_vel_use_mlt_vc_start = .true.



      ! convergence_separate_equ_conv_vel_residuals
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! conv_vel_residual_tol
      ! ~~~~~~~~~~~~~~~~~~~~~

      ! if convergence_separate_equ_conv_vel_residuals is .true., when
      ! using convective velocity variables the residuals of the
      ! convective velocity equation are treated separately. In this
      ! case only the max residual is checked against
      ! conv_vel_max_residual_tol. The low precision is due to double
      ! precision float limitations, which do not allow arbitrary precision.
      ! However, despite the relaxed tolerance on the equations, the actual
      ! value of the convective velocity can be solved down to machine precision.

      ! ::

    convergence_separate_equ_conv_vel_residuals = .true.
    conv_vel_tol_max_residual = 5d-2


      ! convergence_separate_equ_conv_vel_corrections
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! conv_vel_correction_tol
      ! ~~~~~~~~~~~~~~~~~~~~~~~

      ! Similar to convergence_separate_equ_conv_vel_residuals, separates
      ! correction for conv_vel and only applies the conv_vel_max_correction_tol
      ! criteria for a solution. It also allows to define a different scaling for the
      ! correction that takes into account just the changes in the convective velocity
      ! variable, conv_vel_scale_max_correction. Note that the correction represents
      ! changes on the variable ln(conv_vel + s% conv_vel_v0) rather than the actual
      ! convective velocity.

      ! ::

    convergence_separate_equ_conv_vel_corrections = .true.
    conv_vel_tol_max_correction = 1d-3
    conv_vel_min_correction_to_ignore_residual = 1d-8
    conv_vel_scale_max_correction = 5d0


      ! conv_vel_solver_itermin_until_reduce_min_corr_coeff
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ! conv_vel_corr_coeff_limit
      ! ~~~~~~~~~~~~~~~~~~~~~~~~~

      ! When using conv_vel, use this value instead of
      ! solver_itermin_until_reduce_min_corr_coeff
      ! and corr_coeff_limit

      ! ::

    conv_vel_solver_itermin_until_reduce_min_corr_coeff = 15
    conv_vel_corr_coeff_limit = 0.05d0

