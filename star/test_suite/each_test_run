#!/usr/bin/env bash

# if not set elsewhere, we're testing star
if [ -z "$MESA_TEST_MOD" ];then
    export MESA_TEST_MOD="star"
fi

function failure_msg {
    echo "******************** $1 ********************" | tee -a out.txt
}

function success_msg {
    echo "$1" | tee -a out.txt
}

function testhub_log {
    echo "$1" >> testhub.yml
}

# Optional function to update the docs after a test has passed.
# This function checks for images specified in the problem's README.rst file
# and copies images generated by the run to the appropriate location in the docs,
# otherwise it generates an error message
function update_docs {
    start_time=$1
    # run python plotting script plot.py if it exists
    if [ -e plot.py ]; then
        echo "Running plot.py"
        if ! python plot.py; then
            echo "ERROR: plot.py failed to run"
        fi
    fi
    # check for image filenames in README.rst
    if grep -q ".. image::" README.rst; then
        # copy images to docs/ if they exist
        for img in $(grep ".. image::" README.rst | cut -d' ' -f3); do
            filename=$(basename -- "$img")
            extension="${filename##*.}"
            filename="${filename%.*}"
            # find the right img directory out of:
            #   "pgstar_out", "pgstar_out1", "pgstar_out2", "pgstar_out3", 
            #   "png", "png1", "png2", "png3", 
            #   "plt_out", "plt_out1", "plt_out2", "plt_out3"
            img_dir="pgstar_out"
            if [ \( -e "pgstar_out/$filename.$extension" \) -o \( -e "pgstar_out/$filename.ps" \) ]; then
                img_dir="pgstar_out"
            elif [ \( -e "pgstar_out1/$filename.$extension" \) -o \( -e "pgstar_out1/$filename.ps" \) ]; then
                img_dir="pgstar_out1"
            elif [ \( -e "pgstar_out2/$filename.$extension" \) -o \( -e "pgstar_out2/$filename.ps" \) ]; then
                img_dir="pgstar_out2"
            elif [ \( -e "pgstar_out3/$filename.$extension" \) -o \( -e "pgstar_out3/$filename.ps" \) ]; then
                img_dir="pgstar_out3"
            elif [ -e "png/$filename.$extension" ]; then
                img_dir="png"
            elif [ -e "png1/$filename.$extension" ]; then
                img_dir="png1"
            elif [ -e "png2/$filename.$extension" ]; then
                img_dir="png2"
            elif [ -e "png3/$filename.$extension" ]; then
                img_dir="png3"
            elif [ -e "plt_out/$filename.$extension" ]; then
                img_dir="plt_out"
            elif [ -e "plt_out1/$filename.$extension" ]; then
                img_dir="plt_out1"
            elif [ -e "plt_out2/$filename.$extension" ]; then
                img_dir="plt_out2"
            elif [ -e "plt_out3/$filename.$extension" ]; then
                img_dir="plt_out3"
            fi
            image_to_copy="$img_dir/$filename.$extension"
            # if requested extension is .svg, it may need to be converted from .ps (since pgstar outputs .ps):
            if [ "$extension" == "svg" ]; then
                if [ -e $img_dir/$filename.ps ]; then
                    echo "Converting $filename.ps to $filename.svg"
                    if [ ! command -v epstool &> /dev/null]; then
                        echo "ERROR: 'epstool' could not be found! Please install it. Will not be able to convert image to optmized .svg"
                    elif [ ! command -v ps2pdf &> /dev/null]; then
                        echo "ERROR: 'ps2pdf' could not be found! Please install it. Will not be able to convert image to optmized .svg"
                    elif [ ! command -v inkscape &> /dev/null]; then
                        echo "ERROR: 'inkscape' could not be found! Please install it. Will not be able to convert image to optmized .svg"
                    elif [ ! command -v svgo &> /dev/null]; then
                        echo "ERROR: 'svgo' could not be found! Please install it. Will not be able to convert image to optmized .svg"
                    fi
                    epstool --copy --bbox  $img_dir/$filename.ps $img_dir/_TMP_$filename.ps
                    ps2pdf -dEPSCrop $img_dir/_TMP_$filename.ps $img_dir/_TMP_$filename.pdf
                    inkscape --export-page=1 --export-type="svg" --export-extension=org.inkscape.output.scour_inkscape --export-filename=$img_dir/_TMP_$filename.svg $img_dir/_TMP_$filename.pdf
                    svgo $img_dir/_TMP_$filename.svg -o $img_dir/$filename.svg
                    rm $img_dir/_TMP_$filename.ps $img_dir/_TMP_$filename.pdf $img_dir/_TMP_$filename.svg
                fi
            fi
            # perform copy if image exists, and update README.rst
            if [ -e "$image_to_copy" ]; then
                cp "$image_to_copy" docs/
                echo "Updated image $filename.$extension in the docs"
                # replace the line "Last-Run: ..." in README.rst
                LAST_RUN="Last-Run: $(date '+%d%b%Y') (MESA $(git rev-parse --short HEAD)) by $USER on $(hostname) in $(expr `date +%s` - $start_time) seconds using $OMP_NUM_THREADS threads."
                # print name of 
                sed -i "" "/Last-Run: .*/d" README.rst
                echo $LAST_RUN >> README.rst
            else
                echo "ERROR: $image_to_copy not found. Test may no longer be producing this file or may now be producing a different final snapshot number! Update test and README.rst accordingly."
            fi
        done
    else
        echo "(no images found in README.rst)"
    fi
}

# remove known false positive messages from stderr output file (err.txt)
function filter_stderr {
    cp err.txt err.tmp
    # ignore lines like
    #     PGPLOT /xw: cannot connect to X server []
    grep -v PGPLOT err.tmp > err.txt
    rm err.tmp
}

function antepenultimate_photo {
    (
        cd photos
        if [ "$MESA_TEST_MOD" == "binary" ]
        then
            bp=$(ls -t b_* | head -3 | tail -1)
            echo "${bp#b_}"
        else
            ls -t * | head -3 | tail -1
        fi
    )
}

function check_restart {

    if [ -n "${SKIP_RESTARTS}" ]
    then
       echo "skip restarts"
    # make sure we specified a restart file
    elif [ -z "$4" ]
    then
        pwd
        echo "missing name of restart file -- fix do1_test_source for $1"
        echo
    elif [ "$4" != skip ]
    then

        if [ "$4" == auto ]
        then
            photo="$(antepenultimate_photo)"
        else
            photo="$4"
        fi

        testhub_log "restart_photo: $photo"

        # bail out if photo doesn't exist
        if [ ! -e "photos/$photo" ]
        then
            if [ ! -e "photos/b_$photo" ]
            then
                failure_msg "$1 restart failed: $photo does not exist"
                testhub_log "failure_type: :photo_file"
                return 1
            fi
        fi

        # do the restart
        rm -f "$3"
        if command time -q -f '%M' -o mem-re.txt ./re "$photo" >> out.txt 2> err.txt
        then
            testhub_log "mem_re: $(<mem-re.txt)"
        else
            testhub_log "mem_re: -1"
            failure_msg "$1 failed: non-zero exit code"
            testhub_log "failure_type: :exit_code"
            return 1
        fi
        filter_stderr
        if [ -s err.txt ]; then
            failure_msg "$1 failed: wrote to stderr"
            testhub_log "failure_type: :stderr"
            return 1
        fi

        # check that final model matches
        if [[ ! -f ./ck ]]; then
            failure_msg "$1 restart failed: No ck script"
            return 1
        fi


        if ! ./ck
        then
            failure_msg "$1 restart failed: checksum for $3 does not match after ./re $photo"
            testhub_log "failure_type: :photo_checksum"
            return 1
        else
            success_msg "$1 restart: checksum for $3 matches after ./re $photo"
            testhub_log "success_type: :photo_checksum"
            if [ ! -e "checks.md5" ] || [ -e ".ignore_checksum" ]; then
                testhub_log "checksum: 00000000000000000000000000000000"
            else
                testhub_log "checksum: $(cut -b 1-32 < checks.md5)"
            fi
        fi
    fi
}


function check_run {
    # make sure we specified a final model
    if [ -z "$3" ]
    then
        pwd
        echo "missing name of final mod test file -- fix do1_test_source for $1"
        echo
    fi

    # do the run
    date "+   start %H:%M:%S"
    if command time -q -f '%M' -o mem-rn.txt ./rn > out.txt 2> err.txt
    then
        testhub_log "mem_rn: $(<mem-rn.txt)"
    else
        testhub_log "mem_rn: -1"
        failure_msg "$1 failed: non-zero exit code"
        testhub_log "failure_type: :exit_code"
        return 1
    fi
    filter_stderr
    if [ -s err.txt ]; then
        failure_msg "$1 failed: wrote to stderr"
        testhub_log "failure_type: :stderr"
        return 1
    fi
    date "+  finish %H:%M:%S"

    # handle case that case was intentionally skipped
    if grep -i "this test was intentionally skipped" out.txt
    then
        success_msg "$1 was intentionally skipped"
        testhub_log "success_type: :skip"
        return 1 # still return 1 so restart isn't tested
    fi

    # check that test string was printed during the run
    if ! grep -i "$2" out.txt
    then
        echo "test string: $2"
        failure_msg "$1 failed: does not match test string"
        testhub_log "failure_type: :run_test_string"
        return 1
    else
        success_msg "$1 run: test string matches after ./rn"
        testhub_log "success_type: :run_test_string"
    fi

    # check that didn't get "failed to create" message
    if grep -i "failed to create" out.txt
    then
        failure_msg "$1 failed to create expected output model"
        testhub_log "failure_type: :final_model"
        return 1
    fi

    if [ "$3" != skip ]
    then

        if [ -e "$3" ]
        then
            md5sum "$3" > checks.md5
            cp "$3" final_check.mod
        else
            failure_msg "$1 failed to create file for checksum $3"
            testhub_log "failure_type: :final_model"
            return 1
        fi

    fi
}

function build_and_run {

    start_time=`date +%s`

    if ! ./clean; then
        return 1
    fi

    if ! ./mk &> mk.txt; then
        failure_msg "$1 failed: does not compile"
        testhub_log "failure_type: :compilation"
        testhub_log "outcome: :fail"
        return 1
    fi

    # delete final model if it already exists
    if [ -n "$3" ]; then
        rm -f "$3"
    fi

    # don't do check_restart if check_run failed
    if ! check_run "$1" "$2" "$3" "$4"; then

        # handle case that case was intentionally skipped
        if grep -i "this test was intentionally skipped" out.txt
        then
            testhub_log "outcome: :pass"
            return
        else
            testhub_log "outcome: :fail"
            return 1
        fi

    fi

    if ! check_restart "$1" "$2" "$3" "$4"; then
        testhub_log "outcome: :fail"
        return 1
    fi

    # if we made it this far, we passed
    testhub_log "outcome: :pass"

    # if we're updating the docs, try to do it here
    if [ "$has_update_docs_flag" = true ]; then
        update_docs $start_time
    fi
    return

}


function do_one {

id=$((id+1))
if [ "$DO_ALL" == 1 ] || [ "$curr_id" == "$id" ] ; then
    cd "$1" || return
    touch .running

    echo "---" > testhub.yml
    testhub_log "test_case: $1"
    testhub_log "module: :$MESA_TEST_MOD"
    if [ -z "$OMP_NUM_THREADS" ]; then
        testhub_log "omp_num_threads: 0"
    else
        testhub_log "omp_num_threads: $OMP_NUM_THREADS"
    fi
    if [ -z "$MESA_SKIP_OPTIONAL" ]; then
        testhub_log "run_optional: true"
    else
        testhub_log "run_optional: false"
    fi
    if [ -z "$MESA_FPE_CHECKS_ON" ]; then
        testhub_log "fpe_checks: false"
    else
        testhub_log "fpe_checks: true"
    fi
    if [ -z "$MESA_TEST_SUITE_RESOLUTION_FACTOR" ]; then
        testhub_log "resolution_factor: 1"
    else
        testhub_log "resolution_factor: $MESA_TEST_SUITE_RESOLUTION_FACTOR"
    fi
    testhub_log "inlists:"
    echo "build_and_run $1"
    build_and_run "$1" "$2" "$3" "$4"

    rm .running
    cd ..

    echo ""
fi

}

# check for '--update-docs' optional flag
has_update_docs_flag=false
for i in "$@"; do
  case $i in
    -u|--update-docs)
      has_update_docs_flag=true
      echo "(updating docs after successful test runs)"
      shift # past argument with no value
      ;;
    -*|--*)
      echo "Unknown option $i"
      exit 1
      ;;
  esac
done

date
echo ""
./each_test_clean "$1"

echo ""

DO_ALL=0
id=0
curr_id="$1"
if [ ! "$1" ]; then
   DO_ALL=1
fi

date "+DATE: %Y-%m-%d%nTIME: %H:%M:%S"
echo ""

source do1_test_source

date "+DATE: %Y-%m-%d%nTIME: %H:%M:%S"
echo ""
